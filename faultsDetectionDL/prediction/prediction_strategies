#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Aug 27 21:01:19 2021

@author: cherif
"""


"""
class PredictionStrategy:
    def __init__(self, ready_model, rio_dataset, patch_size):
        self.model = ready_model
        self.rio_dataset = rio_dataset
        self.patch_size = patch_size

    def map(self):
        raise NotImplementedError

    def reduce(self, other):
        raise NotImplementedError
"""

import rasterio as rio
import tempfile
import geopandas as gpd
import math
from rasterio.windows import Window
from shapely.geometry import box

class PatchOverlapStrategy():
    
    def __init__(self, ready_model, rio_dataset, patch_size, num_bands=3):
        self.model = ready_model
        self.rio_dataset = rio_dataset
        self.patch_size = patch_size
        self.num_bands = num_bands
        
        out_profile = rio_dataset.profile.copy()
        out_profile.update(count=1, dtype=rio.uint8)
        
        self.out_tempfile = tempfile.NamedTemporaryFile(delete=False).open()
        self.out_rio_dst = rio.open(self.out_tempfile.name, **out_profile)
    
    def __del__(self):
        self.out_rio_dst.close()
        self.out_tempfile.close()
    
    
    def create_patches_windows(self):
        """
        
        """
        IMG_HEIGHT = self.rio_dataset.height
        IMG_WIDTH = self.rio_dataset.width
    
        # Define the grid blocks
        Nx_blocks = math.ceil(IMG_WIDTH/self.patch_size)
        Ny_blocks = math.ceil(IMG_HEIGHT/self.patch_size)
    
        patches_windowd=[]        
        for ix in range(Nx_blocks):
            for iy in range(Ny_blocks):
                win = Window(ix*self.patch_size, iy*self.patch_size, self.patch_size, self.patch_size)                
                #c_box = box(*rio.windows.bounds(win,self.rio_dataset.transform))
                patches_windowd.append(win)
         
        return patches_windowd
    
    def predict(self):
        """
        Windowed prediction
        """
        patches_windows = self.create_patches_windows()
        
        patches_array = []
        for c_patch_window in patches_windows:
            patches_array.append( self.rio_dataset.read(window=c_patch_window)[0:self.num_bands] )
        
        ### predict on all patches
        # !! if any error below try rio interoperability
        preds = self.model.predict(patches_array)
        
        for patch_index ,c_patch_window in enumerate(patches_windows):
            self.out_rio_dst.write(preds[patch_index], window = c_patch_window)



















            